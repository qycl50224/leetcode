### 5.最长回文子串

题干:

给定一个字符串 s，找到 s 中**最长**的**回文子串**。你可以假设 s 的最大长度为 1000。

示例 1：

>输入: "babad"
>输出: "bab"

注意: "aba" 也是一个有效答案。
示例 2：

>输入: "cbbd"
>输出: "bb"



#### 最开始的思路：

既然是要找最长的回文子串，那我就从最长的开始向短的找，找到一个复合的那就是他了，也就是令一个PalinLen 一开始等于给定字符串的长度，然后让他依次减小，然后一个窗口在给定字符串里面判断窗口中的子串是否回文

这样有一个缺点，如果给定的字符串很长，但是存在的最长回文子串很短，则效率很低

![image-20200430142154152](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20200430142154152.png)

结果如我所料

代码如下

```java
class Solution {
    public String longestPalindrome(String s) {
        int PalinLen = s.length();
        while (PalinLen > 0) {
            for(int i = 0; i <= s.length() - PalinLen; i++) {
                String subs = s.substring(i, i + PalinLen);
                // System.out.println(subs.length());
                // System.out.println(subs);
                if (isPalindrome(subs)) {
                    return subs;
                }
            }
            PalinLen --;
        }
        return "";
    }

    // 判断回文如果用栈实现则不用考虑边界条件
    public boolean isPalindrome(String s) {
        // 注意区分halfIndex and halfLen
        
        if (s.length() > 1) {
            int halfLen = (s.length() + 1) / 2;
            // System.out.println("halfLen: " + halfLen );
            for (int i = 0; i <= halfLen - 1; i++) {
                // System.out.println("i: " + s.charAt(i) + "s.length()-1-i: " + s.charAt(s.length()-1-i) );
                if (s.charAt(i) != s.charAt(s.length()-1-i)) {
                    return false;
                }
            }    
        }        
        return true;
    }
}
```

#### 第二个思路

是我现学现卖的动态规划 + 评论区瞟到的反转字符串找公共子串方法

动态规划思想其实很简答，空间换时间，把需要重复算的值存到数组中，来避免后期再次计算

这里我构建一个二维数组，两个维度分别是给定字符串和给定字符串的reverse，这个数组的意义如下

我们称呼给定的数组为`origin`，翻转后的为`reversed`

如果`origin[i] == reversed[j]`，则代表这两个字符有可能是回文串中相对应的两个字符，我们让`dp[i][j] = dp[i-1][j-1] + 1`，这个二维矩阵存在的最大值就是我们最长回文子串的长度

这里有个边界条件的问题是如果i或者j等于0，上面那个推导式不成立

我们用一种类似递归需要的`base case`，把矩阵最上面一行和最左边一列作为我们的`base case`

如果 ``origin[i] == reversed[j]``就把`dp[i][j]`初始化为1，其他的都是0

![image-20200501212852633](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20200501212852633.png)

代码如下

```java
class longestPalindrome {
    public String s;
    public longestPalindrome(String str) {
        s = str;
    }

    public String longestPalindrome() {
        if (s.equals("")) return "";
        String reverse = new StringBuffer(s).reverse().toString();
        int len = s.length();
        int[][] dp = new int[len][len];
        int maxLen = 0, start = 0, end = 0;
        // 初始化为0矩阵

        for ( int i = 0; i < len; i++ ) {
            for (int j = 0; j < len; j++ ) {
                dp[i][j] = 0;
            }
        }

        for ( int j = 0; j < len; j++ ) {
            if (s.charAt(0) == reverse.charAt(j)) {
                dp[0][j] += 1;
            }
        }
		//这里注意因为刚才已经初始化过（0，0）了，所以要跳过去
        for ( int i = 1; i < len; i++) {
            if (s.charAt(i) == reverse.charAt(0)) {
                dp[i][0] += 1;
            }
        }
		//注意从index=1开始
        for ( int i = 1; i < len; i++ ) {
            for ( int j = 1; j < len; j++ ) {
                if ( s.charAt(i) == reverse.charAt(j) ) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                    //System.out.println("dp[i][j]:" + dp[i][j]);
                    // check if it is reasonable
                    if ( dp[i][j] > maxLen && (i + 1 - dp[i][j] + j == len - 1) ) {
                        start = i + 1 - dp[i][j];
                        end = i;
                        maxLen = dp[i][j];
                        System.out.println("start:" + start + "  end:" + end + "  maxLen:" + maxLen);
                    }
                }
            }
        }
        //打印二维矩阵
        for ( int i = 0; i < len; i++) {
            for ( int j = 0; j < len; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        return s.substring(start, end+1);
    }


    public static void main(String args[]) {
        longestPalindrome s = new longestPalindrome("aabccbadabccbx");
        System.out.println(s.longestPalindrome());
    }

}
```

很遗憾这样写的效率还是很低。。。![image-20200501213509842](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20200501213509842.png)

