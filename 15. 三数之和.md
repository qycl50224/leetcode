# 15. 三数之和

题目：

给你一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 `a + b + c = 0` ？请你找出所有满足条件且**不重复**的三元组。

**注意**：答案中不可以包含重复的三元组。

 

**示例：**

给定数组 `nums = [-1, 0, 1, 2, -1, -4]`，

满足要求的三元组集合为：

> [
>   [-1, 0, 1],
>   [-1, -1, 2]
> ]



### 思路一：暴力

纯暴力的代码

```java
public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        int[][][] sums = new int[n][n][n];
        List<List<Integer>> ans = new ArrayList<>();
        Set<Set<Integer>> s = new HashSet<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    sums[i][j][k] = nums[i] + nums[j] + nums[k];
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (sums[i][j][k] == 0) {
                        Set<Integer> ss = new HashSet<>();
                        ss.add(nums[i]);
                        ss.add(nums[j]);
                        ss.add(nums[k]);
                        // 如果al并未出现过
                        if (!s.contains(ss)) {
                            s.add(ss);
                            ArrayList<Integer> al = new ArrayList<>();
                            al.add(nums[i]);
                            al.add(nums[j]);
                            al.add(nums[k]);
                            ans.add(al);
                        }
                    }
                }
            }
        }
        return ans;
    }
```

直接超时

### 思路二：暴力优化

我想把数组里所有的两两之和存储起来，然后遍历一次数组，找每个数对应的两两之和，如果有，则加到`List`中，但是

这样写很容易出bug，而且结构非常复杂且丑陋，找出来的两两之和有可能包含了当前的数

正确的解法是反过来，用一个内外循环找两个数，第三个数再用哈希表去找，就可以把时间复杂度降到了O(N^2)

**错误**代码如下

```java
public List<List<Integer>> threeSum(int[] nums) {
        // 小set里面装的是两数的值
        Map<Integer, Set<Set<Integer>>> mapNum = new HashMap<>();
        Map<Integer, Set<Set<Integer>>> mapIndex = new HashMap<>();
        List<List<Integer>> ans = new ArrayList<>();
        // set同样装的值,不过对应三个数
        List<Set<Integer>> checkDuplicate = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int twoSum = nums[i]+nums[j];
                if (!mapNum.containsKey(twoSum)) mapNum.put(twoSum, new HashSet<Set<Integer>>());
                else {
                    Set<Integer> newSet = new HashSet<>();
                    newSet.add(nums[i]);
                    newSet.add(nums[j]);
                    mapNum.get(twoSum).add(newSet);
                }
            }
        }
        // 对每个数字遍历一遍找他的补值
        for (int i = 0; i < n; i++) {
            int another = - nums[i];
            if (mapNum.containsKey(another)) {
                for (Set<Integer> s: mapNum.get(another)) {
                    Set<Integer> copy = new HashSet<>();
                    for (int num: s) {
                        copy.add(num);
                    }
                    // 需要保证s中没有index i 直接对应的值
                    copy.add(nums[i]);

                    if (!checkDuplicate.contains(copy)) {
                        List<Integer> l = new ArrayList<>();
                        for (int num: s) {
                            l.add(num);
                        }
                        l.add(nums[i]);
                        ans.add(l);
                        checkDuplicate.add(copy);
                    }
                }
            }
        }
        return ans;
    }
```

正确的解法，参考[别人的代码](https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-javajian-ji-ti-jie-by-wang-zi-hao-z/)，加了点注释

```java
public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        // 如果长度小于3，则返回null
        if (n <= 2) return Collections.emptyList();
        // 这里用set是一个细节
        Set<List<Integer>> ans = new LinkedHashSet<>();

        for (int i = 0; i < n - 2; i++) {
            int another = -nums[i];
            Map<Integer, Integer> hm = new HashMap<>(n);
            for (int j = i + 1; j < n; j++) {
                int v = another - nums[j];
                if (hm.containsKey(v)) {
                    List<Integer> l = Arrays.asList(nums[i], hm.get(v), nums[j]);
                    // 这里排序，在添加，是为了去重，排序让具有相同元素的List变得一样
                    // 我们一开始说的set细节也就在这里，因为一样，所以添加没有影响
                    l.sort(Comparator.naturalOrder());
                    ans.add(l);
                } else {
                    // 也许有人想问为什么不是先把哈希表填充满，再来找，
                    // 而是像这样边遍历边填充哈希表
                    // 实际上是因为我们最后找的是一个包括三个数字的组合（请细细体会

                    hm.put(nums[j], nums[j]);
                }
            }
        }
        return new ArrayList<>(ans);
    }

```

