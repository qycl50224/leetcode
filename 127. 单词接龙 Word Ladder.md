# 127. 单词接龙 Word Ladder

level: medium

### 思路：BFS

- 把每个单词看作一个节点，相差一个字符的两两节点相连，这样就构成了一张无向图
- 我们要找的就是最短的变化次数，相当于从节点A到节点B的最短路径
- 先构造邻接表，用一个 `List<List<Integer>>`来表示，Integer代表节点在输入的`wordList`的index
- 为了加快查询速度，用一个String数组把`wordList`的单词扒下来
- 用一个队列`Queue`来实现后续的bfs过程
- 用一个`int`数组`level`来表示每个节点到`startword`的最短距离，假设相邻两个节点距离为1
- 还有一个`Set`来记录哪些节点已经入队，如果某个节点已经在set中，则不用再将他入队，代表之前已经得到了这个节点的`level`，可以直接跳过
- bfs前准备过程
  - 实现邻接表
  - 把第一波`level`为1也就是和`startWord`直接相邻的节点入`queue`和入`set`
- 算法的核心思想，从初始节点开始，访问离初始直接与初始节点相邻的所有节点，这些节点的`level`为1，然后是与相邻节点相邻的节点，`level`为2，直到找到`endWord`节点，所以找到的必定是最近的



```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Integer> q = new LinkedList<>();
        List<List<Integer>> adjecancy = new LinkedList<>();
        String[] words = new String[wordList.size()]; // to quick find
        Set<Integer> set = new HashSet<>(); // to store visited word
        int[] level = new int[wordList.size()]; // the shortest path to word[i]
        int end = -1;

        for (int i = 0; i < wordList.size(); i++) {
            words[i] = wordList.get(i);
            if (words[i].equals(endWord)) end = i;
        }
        if (end == -1 ) return 0; // end doesn't change means no endWord

        // initialize list
        for (int i = 0; i < words.length; i++) {
            adjecancy.add(new ArrayList<>());
        }

        // initialize the queue with all words that has one diffrence with startWord and add them to set
        for (int i = 0; i < words.length; i++) {
            if (checkDifference(beginWord, words[i])) {
                q.add(i);
                set.add(i);
                level[i] = 1;
            }
        }

        // generate the adjecancy matrix
        for (int i = 0; i < words.length; i++) {
            String w1 = words[i];
            for (int j = 0; j < words.length; j++) {
                if (i == j) continue;
                String w2 = words[j];
                if (checkDifference(w1, w2)) {
                    adjecancy.get(i).add(j);
                }
            }
        }

        // bfs
        while(!q.isEmpty()) {
            int pre = q.poll();
            if (pre == end) return level[pre]+1; // plus the startWord
            for (int i: adjecancy.get(pre)) {
                if (!set.contains(i)) {
                    q.add(i);
                    set.add(i);
                    level[i] = level[pre]+1;
                }
            }
        }


        return 0;
    }

    private boolean checkDifference(String s1, String s2) {
        int diff = 0;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) diff++;
            if (diff >= 2) return false;
        }
        return true;
    }
```

time: 899ms 22%

space: 40.8 MB 48%