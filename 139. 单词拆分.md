# 139. 单词拆分

难度：medium

题目：

给定一个非空字符串 s 和一个包含非空单词列表的字典 `wordDict`，判定 `s` 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

> **示例 1：** 
>
> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

> **示例 2**：
>
> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 输出: true
> 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
>      注意你可以重复使用字典中的单词。

>  **示例 3：**
>
> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 输出: false



解法一：暴力递归

- 若我们尝试以人的思维去判断一个字符串是否符合要求，就可以得到这种方法的伪代码
- 找到一个字典中有的词，把他剩下的字符串作为新的字符串进行匹配
- 如果整个下来不符合，就往外循环跳，找**新的第一个子单词**

复杂度：

- 时间复杂度：O（N^N），参考官方解答，考虑最坏情况 s = 'aaaaaaaa' 。每一个前缀都在字典中，此时回溯树的复杂度会达到 `n^n` 
  n
- 空间复杂度：O（N） 递归调用

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        if (wordDict.contains(s)) return true;
        
        return helper(s, 0, wordDict);

    }
    private boolean helper(String s, int start, List<String> wordDict) {
        if (start == s.length()) return true;
        for (int end = start + 1; end <= s.length(); end++) {
            // 细节，这里的递归是放在条件判断里面，而不是返回中，我一开始就是用返回递归，导致不知道怎么找新的第一个子单词
            if (wordDict.contains(s.substring(start, end)) && helper(s, end, wordDict)) {
                return true;
            }
        }
        return false;
    }
}
```

但是这种方法会超时，暴力嘛，意料之中